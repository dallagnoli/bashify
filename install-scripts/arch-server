#!/bin/sh
set -e

# Print an ASCII art logo
logo() {
printf "_____________________________________________ 
     __              __        _  _        
    /  )        /   /  )      // //        
   /--/ __  _. /_  /  / __.  // // __.  _, 
  /  (_/ (_(__/ /_/__/_(_/|_</_</_(_/|_(_)_
                                        /| 
                                       |/  
_____________________________________________

    'Every Little Thing He Does Is Magic'    
_____________________________________________\n"
}

# Make sure the script is run as root
verify_root() {
    if [ "$(id -u)" -ne 0 ]; then
        printf "ERROR: This script must be run as root.\n"
        exit 1
    fi
}

# Make sure the script is run from an Arch Linux ISO environment
verify_iso() {
    if [ ! -e /run/archiso/bootmnt/arch/x86_64/airootfs.sfs ]; then
        printf "ERROR: This script must be run from an Arch Linux ISO environment.\n"
        exit 1
    fi
}

# Make sure that pacman is not locked
verify_pacman() {
    if [ -f /var/lib/pacman/db.lck ]; then
        if pgrep -x pacman >/dev/null; then
            printf "ERROR: Pacman is currently running. Close it before proceeding.\n"
            exit 1
        else
            rm -f /var/lib/pacman/db.lck
        fi
    fi
}

# Group all verification functions
verify_all() {
    verify_root
    verify_iso
    verify_pacman
}

# Detect if the system is running in UEFI or BIOS mode
boot_mode() {
    if [ -f /sys/firmware/efi/fw_platform_size ]; then
        printf "\n>> System will be installed in UEFI mode.\n"
        BOOT=UEFI
    else
        printf "\n>> System will be installed in BIOS mode.\n"
        BOOT=BIOS
    fi
}

# Prompt the user to select a filesystem
filesystem() {
    while :; do
        printf "_____________________________________________

             Select a Filesystem
_____________________________________________ 

  [1] ext4: Stable, fast, and proven. 
  Default choice for most users.

  [2] f2fs: Optimized for SSDs and eMMC. 
  Improves flash longevity and speed.

  [3] btrfs: Advanced features: snapshots, 
  compression, subvolumes.

  [4] xfs: High-performance journaling. 
  Ideal for large files and workloads.
_____________________________________________

Make your choice (1-4), default is ext4: "

        read -r fs_choice

        case $fs_choice in
            ""|1 ) 
                printf ">> Selected filesystem: ext4\n"
                export FS="ext4"
                break
                ;;
            2 )
                printf ">> Selected filesystem: f2fs\n"
                export FS="f2fs"
                break
                ;;
            3 )
                printf ">> Selected filesystem: btrfs\n"
                export FS="btrfs"
                break
                ;;
            4 )
                printf ">> Selected filesystem: xfs\n"
                export FS="xfs"
                break
                ;;
            * )
                printf ">> Invalid option. Please enter 1–4.\n"
                ;;
        esac
    done
}

# Prompt the user to select the installation disk
disk() {
    disk_list=$(mktemp)
    trap 'rm -f "$disk_list"' EXIT

    while :; do
        printf "_____________________________________________

                Select a Disk
_____________________________________________\n\n"

        lsblk -dn -o NAME,SIZE,TYPE,TRAN | awk '
            $3 == "disk" && $4 != "usb" && $1 !~ /^(loop|ram|sr|fd)/ {
                print $1, $2
            }' > "$disk_list"

        disk_total=$(wc -l < "$disk_list")
        if [ "$disk_total" -eq 0 ]; then
            printf "ERROR: No valid disks found.\n"
            exit 1
        fi

        i=1
        while [ "$i" -le "$disk_total" ]; do
            line=$(sed -n "${i}p" "$disk_list")
            disk_name=$(printf '%s\n' "$line" | cut -d' ' -f1)
            disk_size=$(printf '%s\n' "$line" | cut -d' ' -f2)
            if [ "$i" -eq "$disk_total" ]; then
                printf "  [%s] %s: %s\n" "$i" "$disk_name" "$disk_size"
            else
                printf "  [%s] %s: %s\n\n" "$i" "$disk_name" "$disk_size"
            fi
            i=$((i + 1))
        done

        printf "_____________________________________________\n\nMake your choice (1-%d): " "$disk_total"
        read -r disk_choice

        case $disk_choice in
            ''|*[!0-9]*)
                printf ">> Invalid option. Please enter 1-%d.\n" "$disk_total"
                ;;
            *)
                if [ "$disk_choice" -lt 1 ] || [ "$disk_choice" -gt "$disk_total" ]; then
                    printf ">> Invalid option. Please enter 1-%d.\n" "$disk_total"
                else
                    disk_selected=$(sed -n "${disk_choice}p" "$disk_list" | cut -d' ' -f1)
                    printf ">> Selected disk: %s\n" "$disk_selected"
                    export DISK="/dev/$disk_selected"
                    break
                fi
                ;;
        esac
    done
}

# Prompt the user to set a hostname
hostname() {
    while :; do
        printf "_____________________________________________

             Setting a Hostname
_____________________________________________ 

  -> Must start with a letter.

  -> Cannot end with a hyphen.

  -> Avoid dots and uppercase letters.

  -> Only lowercase letters, digits, and 
     hyphens.

  -> Length: 1–63 characters.
_____________________________________________

Type your hostname: "

        read -r hostname_input

        if printf '%s' "$hostname_input" | grep -Eq '^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$'; then
            printf ">> Hostname has been set to: %s\n" "$hostname_input"
            export HOSTNAME="$hostname_input"
            break
        else
            printf ">> Invalid hostname. Please try again.\n"
        fi
    done
}

# Prompt the user to set a username
username() {
    while :; do
        printf "_____________________________________________

             Setting a Username
_____________________________________________ 

  -> Must start with a letter or underscore.

  -> Cannot end with a hyphen or underscore.

  -> Avoid dots and uppercase letters.

  -> Only lowercase letters, digits, 
     underscores and hyphens.

  -> Length: 1–32 characters.
_____________________________________________

Type your username: "

        read -r username_input

        if [ "$username_input" != "root" ] && printf '%s' "$username_input" | grep -Eq '^[a-z_][a-z0-9_-]{0,30}[a-z0-9]$'; then
            printf ">> Username has been set to: %s\n" "$username_input"
            export USERNAME="$username_input"
            break
        else
            printf ">> Invalid username. Please try again.\n"
        fi
    done
}

